# Лабораторная работа по предмету "Облачные технологии и услуги"

## Техническое задание

1. **Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов**
   
2. **Написать “хороший” Dockerfile, в котором эти плохие практики исправлены**
   
3. **В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат**
   
4. **В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.**

## Начало работы

1. **Напишем простое приложение на Python, далее для него уже будем писать наши docker файлы**

    ![alt text](<images/1.png>)

2. **Напишем “плохой” Dockerfile, используя несколько “bad practices”**

    ```
    FROM python:latest

    USER root

    WORKDIR /app

    COPY . .

    RUN pip install --no-cache-dir -r requirements.txt

    CMD ["python", "app.py"]
    ```

3. **Создадим образ на основе “плохого” Dockerfile**

    ```docker build -t flask-app .```

    ![alt text](<images/2.png>)

    ![alt text](<images/3.png>)

4. **Напишем “хороший” Dockerfile, используя несколько “good practices”**

    ```
    FROM python:3.11-slim

    RUN useradd -ms /bin/bash anton_user

    USER anton_user

    WORKDIR /app

    COPY requirements.txt .

    RUN pip install --no-cache-dir -r requirements.txt

    COPY app.py .

    CMD ["python", "app.py"]
    ```

5. **Создадим образ на основе “хорошего” Dockerfile**

    ```docker build -t flask-app-2 .```

    ![alt text](<images/5.png>)

    ![alt text](<images/4.png>)

6. **Результаты и вывод**

    Мы можем сразу же заметить, что образ, созданный на основе “плохого” Dockerfile собирается намного медленнее и весит намного больше образа, созданного на основе “хорошего” Dockerfile.


## Dockerfile Bad Practices

### 1. Не указывать конкретную версию образа.

* **Почему это плохо:** 
    
    * **Непредсказуемость:** Использование тега latest не гарантирует, что образ будет всегда идентичным. Если базовый образ изменится (например, новая версия Python), это может привести к проблемам совместимости или неожиданному поведению приложения.
    
    * **Проблемы с воспроизводимостью:** При сборке контейнера в будущем или на другом сервере могут возникнуть разные результаты, так как latest будет указывать на другую версию образа.

### 2. Запускать контейнер от root.

* **Почему это плохо:** 
    
    * **Безопасность:** По умолчанию контейнер запускается от пользователя ```root```, что создает риск эксплуатации уязвимостей. Если злоумышленник получит доступ к контейнеру, он получит привилегии ```root```.
    
    * **Плохие практики безопасности:** Даже если контейнер изолирован, запуск от root увеличивает шансы атак на другие системы.

### 3. Установливать зависимости после копирования файлов.

* **Почему это плохо:** 
    
    * **Неэффективное использование кэша:** Каждый раз при изменении кода (например, app.py), Docker должен заново установить все зависимости, даже если они не изменились. Это увеличивает время сборки и делает процесс менее эффективным.
    
    * **Большой размер образа:** Каждый шаг сборки создает слой в образе, и если зависимости меняются часто, образ может увеличиться в размерах.

### 4. Копировать абсолютно все файлы в контейнер и не использовать .dockerignore (тем самым увеличивая размер dockerfile).

* **Почему это плохо:** 
    
    * **Ненужные файлы в образе:** Абсолютно все файлы из рабочей директории будут скопированы в контейнер, включая временные файлы, документацию, файлы конфигурации редакторов и другие ненужные файлы. Это увеличивает размер Docker-образа.

    * **Замедление сборки:** Большое количество ненужных файлов замедляет процесс копирования и, как следствие, сборку. 


## Dockerfile Good Practices

### 1. Использовать тег для указания версии образа.

* **Исправление:** 
    
    * **Конкретизация версии:** Использование конкретного тега версии (```python:3.11-slim```) позволяет всегда работать с одной и той же версией Python. Это гарантирует стабильность.

* **Влияние:** 
    
    * **Предсказуемость:** Теперь сборка всегда будет использовать одно и то же окружение, независимо от изменений в репозитории базовых образов.

    * **Оптимизация размера:** Использование тега ```slim``` значительно уменьшает размер образа.

### 2. Создать отдельного пользователя, чтобы не запускать контейнер от root.

* **Исправление:**
    
    * **Создание отдельного пользователя:** Создаем пользователя и переключаемся на него с помощью команды ```USER```. Это позволяет минимизировать риск атак, т.к. контейнер работает с минимальными правами.

* **Влияние:** 
    * **Повышение безопасности:** Контейнер запускается не от имени ```root```, что существенно снижает риски эксплуатации уязвимостей в случае атаки на контейнер.

### 3. Cначала устанавливать зависимости, а потом уже копировать файлы.

* **Исправление:** 
    
    * **Сначала установка зависимостей:** Сначала копируем файл requirements.txt и устанавливаем зависимости. Таким образом, если код приложения меняется, но зависимости остаются прежними, Docker использует кэш для ускорения сборки.

* **Как это повлияло:** 
    
    * **Оптимизация сборки:** Docker кэширует слои, и при изменении только кода приложения не нужно заново устанавливать все зависимости. Это ускоряет сборку.
    
    * **Уменьшение размера образа:** Меньшее количество изменяющихся слоев уменьшает итоговый размер Docker-образа.

### 4. Копировать только нужные нам файлы и добавлять .dockerignore файл.

* **Исправление:** 
    
    * **Использование файла .dockerignore:** Этот файл исключает ненужные файлы (например, временные файлы или файлы конфигурации редактор и т.п), которые не нужны для работы приложения внутри контейнера.

* **Влияние:** 
    
    * **Уменьшение размера образа:** Меньше ненужных файлов попадает в контейнер, тем самым уменьшается его размер.
    
    * **Ускорение сборки:** Сокращается объем данных для копирования, а значит, уменьшается время на сборку.

## Плохие практики по работе с контейнерами.

### 1. Не обновлять образы и контейнеры.

* **Последствия:** 
    
    * **Уязвимости безопасности:** Использование устаревших образов может привести к тому, что ваше приложение будет уязвимо для атак, которые уже были исправлены в новых версиях образов.

    * **Проблемы совместимости:** Новые зависимости или изменения в языках программирования могут вызвать проблемы при взаимодействии с устаревшими библиотеками или фреймворками.

* **Рекомендации:**

    Необходимо регулярно проверять и обновлять образы, чтобы быть уверенным, что используются самые последние версии с актуальными исправлениями и улучшениями.


### 2. Не использовать ограничение по ресурсам для контейнеров.

* **Последствия:** 
    
    * **Падение производительности:** Если один контейнер использует все доступные ресурсы, другие контейнеры могут не получить достаточного количества ресурсов, что приведет к их замедлению или даже зависанию.
    
    * **Неожиданные сбои:** В случае исчерпания ресурсов может произойти аварийное завершение работы контейнеров или самого Docker-демона, что приведет к потере данных или недоступности сервисов.

* **Рекомендации:**

    При запуске контейнеров используйте параметры ```--memory``` и ```--cpus``` для ограничения ресурсов, которые могут использовать ваши контейнеры. Это поможет избежать проблем с производительностью и обеспечит более стабильную работу всех контейнеров на хосте.